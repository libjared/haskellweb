From 0594d0abd78a48afd4ab46bdcc039c563b076726 Mon Sep 17 00:00:00 2001
From: libjared <libjared@users.noreply.github.com>
Date: Tue, 7 Jun 2022 15:52:57 -0500
Subject: [PATCH] Rip out short-text

---
 aeson.cabal                           |  2 --
 src/Data/Aeson/Encoding.hs            |  1 -
 src/Data/Aeson/Encoding/Internal.hs   | 10 ----------
 src/Data/Aeson/Internal/ByteString.hs |  2 +-
 src/Data/Aeson/Key.hs                 | 15 ++-------------
 src/Data/Aeson/TH.hs                  | 15 ++++++++++-----
 src/Data/Aeson/Types/FromJSON.hs      |  9 ---------
 src/Data/Aeson/Types/ToJSON.hs        | 10 ----------
 tests/PropertyRoundTrip.hs            |  2 --
 tests/SerializationFormatSpec.hs      |  2 --
 10 files changed, 13 insertions(+), 55 deletions(-)

diff --git a/aeson.cabal b/aeson.cabal
index 1af6b36..60a2c71 100644
--- a/aeson.cabal
+++ b/aeson.cabal
@@ -124,7 +124,6 @@ library
     , semialign             >=1.2      && <1.3
     , strict                >=0.4      && <0.5
     , tagged                >=0.8.6    && <0.9
-    , text-short            >=0.1.5    && <0.2
     , th-abstraction        >=0.3.0.0  && <0.5
     , these                 >=1.1.1.1  && <1.2
     , unordered-containers  >=0.2.10.0 && <0.3
@@ -209,7 +208,6 @@ test-suite aeson-tests
     , tasty-quickcheck
     , template-haskell
     , text
-    , text-short
     , these
     , time
     , time-compat
diff --git a/src/Data/Aeson/Encoding.hs b/src/Data/Aeson/Encoding.hs
index e1d17d8..d0eb13d 100644
--- a/src/Data/Aeson/Encoding.hs
+++ b/src/Data/Aeson/Encoding.hs
@@ -25,7 +25,6 @@ module Data.Aeson.Encoding
     , emptyObject_
     , text
     , lazyText
-    , shortText
     , string
     , list
     , dict
diff --git a/src/Data/Aeson/Encoding/Internal.hs b/src/Data/Aeson/Encoding/Internal.hs
index b380cfd..1df4b74 100644
--- a/src/Data/Aeson/Encoding/Internal.hs
+++ b/src/Data/Aeson/Encoding/Internal.hs
@@ -30,7 +30,6 @@ module Data.Aeson.Encoding.Internal
     , key
     , text
     , lazyText
-    , shortText
     , string
     , list
     , dict
@@ -80,7 +79,6 @@ import qualified Data.Aeson.Encoding.Builder as EB
 import qualified Data.ByteString.Builder as B
 import qualified Data.ByteString.Lazy as BSL
 import qualified Data.Text.Lazy as LT
-import qualified Data.Text.Short as ST
 
 -- | An encoding of a JSON value.
 --
@@ -256,14 +254,6 @@ lazyText t = Encoding $
     B.char7 '"' <>
     LT.foldrChunks (\x xs -> EB.unquoted x <> xs) (B.char7 '"') t
 
--- | @since 2.0.2.0
-shortText :: ST.ShortText -> Encoding' a
-shortText t = Encoding $
-    B.char7 '"' <>
-    -- TODO: if we can determine whether all characters are >=0x20 && <0x80
-    -- we could use underlying ShortByteString directly.
-    EB.unquoted (ST.toText t) <> B.char7 '"'
-
 string :: String -> Encoding' a
 string = Encoding . EB.string
 
diff --git a/src/Data/Aeson/Internal/ByteString.hs b/src/Data/Aeson/Internal/ByteString.hs
index 4a59e33..e002c3f 100644
--- a/src/Data/Aeson/Internal/ByteString.hs
+++ b/src/Data/Aeson/Internal/ByteString.hs
@@ -3,7 +3,7 @@
 {-# LANGUAGE MagicHash #-}
 {-# LANGUAGE TemplateHaskellQuotes #-}
 module Data.Aeson.Internal.ByteString (
-    mkBS, 
+    mkBS,
     withBS,
     liftSBS,
 ) where
diff --git a/src/Data/Aeson/Key.hs b/src/Data/Aeson/Key.hs
index 8a56771..59d8301 100644
--- a/src/Data/Aeson/Key.hs
+++ b/src/Data/Aeson/Key.hs
@@ -10,8 +10,6 @@ module Data.Aeson.Key (
     toText,
     fromText,
     coercionToText,
-    toShortText,
-    fromShortText,
 ) where
 
 import Prelude (Eq, Ord, (.), Show (..), String, Maybe (..))
@@ -29,7 +27,6 @@ import Text.Read (Read (..))
 
 import qualified Data.String
 import qualified Data.Text as T
-import qualified Data.Text.Short as ST
 import qualified Language.Haskell.TH.Syntax as TH
 import qualified Test.QuickCheck as QC
 
@@ -53,19 +50,11 @@ toText = unKey
 --
 -- Using 'coercing' we can make more efficient implementations
 -- when 'Key' is backed up by 'Text' without exposing internals.
--- 
+--
 coercionToText :: Maybe (Coercion Key Text)
 coercionToText = Just Coercion
 {-# INLINE coercionToText #-}
 
--- | @since 2.0.2.0
-toShortText :: Key -> ST.ShortText
-toShortText = ST.fromText . unKey
-
--- | @since 2.0.2.0
-fromShortText :: ST.ShortText -> Key
-fromShortText = Key . ST.toText
-
 -------------------------------------------------------------------------------
 -- instances
 -------------------------------------------------------------------------------
@@ -74,7 +63,7 @@ instance Read Key where
     readPrec = fromString <$> readPrec
 
 instance Show Key where
-    showsPrec d (Key k) = showsPrec d k 
+    showsPrec d (Key k) = showsPrec d k
 
 instance Data.String.IsString Key where
     fromString = fromString
diff --git a/src/Data/Aeson/TH.hs b/src/Data/Aeson/TH.hs
index 4f61b55..b00def3 100644
--- a/src/Data/Aeson/TH.hs
+++ b/src/Data/Aeson/TH.hs
@@ -150,8 +150,8 @@ import qualified Data.Set as Set (empty, insert, member)
 import qualified Data.Text as T (pack, unpack)
 import qualified Data.Vector as V (unsafeIndex, null, length, create, empty)
 import qualified Data.Vector.Mutable as VM (unsafeNew, unsafeWrite)
-import qualified Data.Text.Short as ST
-import Data.ByteString.Short (ShortByteString)
+import qualified Data.ByteString.Short as BS (ShortByteString, pack)
+import qualified Data.ByteString.Internal as BSI (c2w)
 import Data.Aeson.Internal.ByteString
 import Data.Aeson.Internal.TH
 
@@ -310,7 +310,7 @@ mkToEncodingCommon :: JSONClass -- ^ Which class's method is being derived.
                    -> Q Exp
 mkToEncodingCommon = mkFunCommon (\jc _ -> consToValue Encoding jc)
 
-type LetInsert = ShortByteString -> ExpQ
+type LetInsert = BS.ShortByteString -> ExpQ
 
 -- | Helper function used by both 'deriveToJSON' and 'mkToJSON'. Generates
 -- code to generate a 'Value' or 'Encoding' of a number of constructors. All
@@ -587,7 +587,12 @@ fromPairsE _ = ([|fromPairs|] `appE`)
 pairE :: LetInsert -> ToJSONFun -> String -> ExpQ -> ExpQ
 pairE letInsert Encoding k v = [| E.unsafePairSBS |] `appE` letInsert k' `appE` v
   where
-    k' = ST.toShortByteString $ ST.pack $ "\"" ++ concatMap escapeAscii k ++ "\":"
+    -- TS.pack :: [Char] -> ShortText
+    -- TS.toShortByteString :: ShortText -> ShortByteString
+    -- BS.pack :: [Word8] -> ByteString
+    -- BSS.pack :: [Word8] -> ShortByteString
+    -- BSS.toShort :: ByteString -> ShortByteString
+    k' = BS.pack $ map BSI.c2w $ "\"" ++ concatMap escapeAscii k ++ "\":"
 
     escapeAscii '\\' = "\\\\"
     escapeAscii '\"' = "\\\""
@@ -1154,7 +1159,7 @@ instance {-# OVERLAPPABLE #-} LookupField a where
 
 instance {-# INCOHERENT #-} LookupField (Maybe a) where
     lookupField pj _ _ = parseOptionalFieldWith pj
- 
+
 #if !MIN_VERSION_base(4,16,0)
 instance {-# INCOHERENT #-} LookupField (Semigroup.Option a) where
     lookupField pj tName rec obj key =
diff --git a/src/Data/Aeson/Types/FromJSON.hs b/src/Data/Aeson/Types/FromJSON.hs
index e6996eb..62b758d 100644
--- a/src/Data/Aeson/Types/FromJSON.hs
+++ b/src/Data/Aeson/Types/FromJSON.hs
@@ -145,7 +145,6 @@ import qualified Data.Strict as S
 import qualified Data.Text as T
 import qualified Data.Text.Encoding as T
 import qualified Data.Text.Lazy as LT
-import qualified Data.Text.Short as ST
 import qualified Data.Tree as Tree
 import qualified Data.UUID.Types as UUID
 import qualified Data.Vector as V
@@ -1695,14 +1694,6 @@ instance FromJSON LT.Text where
 instance FromJSONKey LT.Text where
     fromJSONKey = FromJSONKeyText LT.fromStrict
 
--- | @since 2.0.2.0
-instance FromJSON ST.ShortText where
-    parseJSON = withText "Lazy Text" $ pure . ST.fromText
-
--- | @since 2.0.2.0
-instance FromJSONKey ST.ShortText where
-    fromJSONKey = FromJSONKeyText ST.fromText
-
 
 instance FromJSON Version where
     parseJSON = withText "Version" parseVersionText
diff --git a/src/Data/Aeson/Types/ToJSON.hs b/src/Data/Aeson/Types/ToJSON.hs
index db3c2f7..fb96019 100644
--- a/src/Data/Aeson/Types/ToJSON.hs
+++ b/src/Data/Aeson/Types/ToJSON.hs
@@ -125,7 +125,6 @@ import qualified Data.Strict as S
 import qualified Data.Text as T
 import qualified Data.Text.Encoding as T
 import qualified Data.Text.Lazy as LT
-import qualified Data.Text.Short as ST
 import qualified Data.Tree as Tree
 import qualified Data.UUID.Types as UUID
 import qualified Data.Vector as V
@@ -1466,15 +1465,6 @@ instance ToJSON LT.Text where
 instance ToJSONKey LT.Text where
     toJSONKey = toJSONKeyText (LT.toStrict)
 
--- | @since 2.0.2.0
-instance ToJSON ST.ShortText where
-    toJSON = String . ST.toText
-    toEncoding = E.shortText
-
--- | @since 2.0.2.0
-instance ToJSONKey ST.ShortText where
-    toJSONKey = ToJSONKeyText Key.fromShortText E.shortText
-
 
 instance ToJSON Version where
     toJSON = toJSON . showVersion
diff --git a/tests/PropertyRoundTrip.hs b/tests/PropertyRoundTrip.hs
index 3075eb6..e2c5472 100644
--- a/tests/PropertyRoundTrip.hs
+++ b/tests/PropertyRoundTrip.hs
@@ -27,7 +27,6 @@ import Test.Tasty.QuickCheck (testProperty)
 import Types
 import qualified Data.Text as T
 import qualified Data.Text.Lazy as LT
-import qualified Data.Text.Short as ST
 import qualified Data.UUID.Types as UUID
 import qualified Data.Strict as S
 import qualified Data.Fix as F
@@ -84,7 +83,6 @@ roundTripTests =
     , testProperty "Strict These" $ roundTripEq (undefined :: S.These Int Char)
     , testProperty "Strict Maybe" $ roundTripEq (undefined :: S.Maybe Int)
     , testProperty "Solo Int" $ roundTripEq (undefined :: Solo Int)
-    , testProperty "ShortText" $ roundTripEq (undefined :: ST.ShortText)
     , roundTripFunctorsTests
     , testGroup "ghcGenerics" [
         testProperty "OneConstructor" $ roundTripEq OneConstructor
diff --git a/tests/SerializationFormatSpec.hs b/tests/SerializationFormatSpec.hs
index 95b6ee4..62bd81e 100644
--- a/tests/SerializationFormatSpec.hs
+++ b/tests/SerializationFormatSpec.hs
@@ -61,7 +61,6 @@ import qualified Data.Vector as Vector
 import qualified Data.Fix as F
 import qualified Data.Strict as S
 import qualified Data.Text.Lazy as LT
-import qualified Data.Text.Short as ST
 
 tests :: [TestTree]
 tests =
@@ -95,7 +94,6 @@ jsonExamples =
 
   , example "Text" "\"foo\"" ("foo" :: Text)
   , example "Lazy Text" "\"foo\"" ("foo" :: LT.Text)
-  , example "ShortText" "\"foo\"" ("foo" :: ST.ShortText)
 
   , ndExample "HashMap Int Int"
         [ "{\"0\":1,\"2\":3}", "{\"2\":3,\"0\":1}"]
-- 
2.35.1

